<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#2b6cb0" />
  <title>Rastreador - PWA</title>

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

  <link rel="manifest" href="manifest.json">

  <style>
    body {
      background: #f0f2f5;
    }
    header {
      background: linear-gradient(90deg,#2b6cb0,#4c9bd6);
      color: white;
      padding: 20px;
      text-align: center;
      margin-bottom: 20px;
    }
    #map {
      height: 55vh;
      border-radius: 10px;
      overflow: hidden;
    }
    .hidden {
      display: none !important;
    }
  </style>

  <!-- Apple PWA -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
</head>
<body>

<header>
  <h1 class="h3 mb-1">Rastreador de Corrida</h1>
  <p class="mb-0">Use o GPS do celular para medir distância, tempo e progresso automático.</p>
</header>


<div class="container">

  <!-- CONTROLES -->
  <div class="card shadow-sm mb-3">
    <div class="card-body">

      <h5 class="card-title mb-3">Configurações</h5>

      <div class="row g-3">

        <div class="col-6">
          <label class="form-label">Distância total (m)</label>
          <input type="number" id="targetDistance" class="form-control" placeholder="ex: 500">
        </div>

        <div class="col-6">
          <label class="form-label">Avisar a cada (m)</label>
          <input type="number" id="progressStep" class="form-control" placeholder="ex: 100">
        </div>

      </div>

      <div class="mt-4 d-flex gap-2">
        <button id="startBtn" class="btn btn-success flex-fill">Iniciar</button>
        <button id="pauseBtn" class="btn btn-warning flex-fill" disabled>Pausar</button>
        <button id="stopBtn" class="btn btn-danger flex-fill" disabled>Parar</button>
      </div>

    </div>
  </div>

  <!-- ESTATÍSTICAS -->
  <div class="card shadow-sm mb-3">
    <div class="card-body">

      <h5 class="card-title mb-3">Estatísticas</h5>

      <div class="row text-center">
        <div class="col-6 col-md-3 mb-2">
          <div class="fw-bold">Tempo</div>
          <div id="time">00:00:00</div>
        </div>

        <div class="col-6 col-md-3 mb-2">
          <div class="fw-bold">Distância</div>
          <div id="distance">0 m</div>
        </div>

        <div class="col-6 col-md-3 mb-2">
          <div class="fw-bold">Velocidade</div>
          <div id="speed">0 km/h</div>
        </div>

        <div class="col-6 col-md-3 mb-2">
          <div class="fw-bold">Pace</div>
          <div id="pace">0:00 /km</div>
        </div>
      </div>

    </div>
  </div>

  <!-- MAPA -->
  <div class="card shadow-sm mb-3">
    <div class="card-body">
      <h5 class="card-title mb-3">Mapa</h5>
      <div id="map" class="hidden"></div>
    </div>
  </div>

</div>


<footer class="text-center mt-4 mb-3 text-muted">
  <small>Melhor experiência: Chrome Android | Safari iOS tem limitações para rastreamento em background.</small>
</footer>

<!-- Leaflet -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Bootstrap Bundle -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

  <script>
  // --- Config e estado ---
  let map, polyline, watchId = null;
  let lastPos = null;
  let coords = [];
  let totalMeters = 0;
  let startTime = null;
  let timerInterval = null;
  let paused = false;
  let targetDistance = 0;
  let reachedTarget = false;
  let lastTargetTime = 0;
  let progressStep = 0;
  let nextProgressMark = 0;
  let targetReached = false;

  const el = {
    startBtn: null, pauseBtn: null, stopBtn: null, 
    time: null, distance: null, speed: null, pace: null, logtxt: null
  };

  function log(msg){
    const now = new Date().toLocaleTimeString();
    const out = `[${now}] ${msg}\n`;
    console.log(out);
    if(el.logtxt){ el.logtxt.textContent += out; }
  }

  function initMap(){
    map = L.map('map', { zoomControl: true }).setView([-23.55, -46.63], 13); // default São Paulo
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap'
    }).addTo(map);
    polyline = L.polyline([], { weight: 5 }).addTo(map);
  }

  // Haversine - retorna metros
  function haversine(lat1, lon1, lat2, lon2){
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  function formatTime(ms){
    const s = Math.floor(ms/1000) % 60;
    const m = Math.floor(ms/60000) % 60;
    const h = Math.floor(ms/3600000);
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }

  function formatDistance(meters){
    if(meters < 1000) return `${meters.toFixed(1)} m`;
    return `${(meters/1000).toFixed(3)} km`;
  }

  function formatSpeedMetersPerSec(ms){
    const kmh = ms * 3.6;
    return kmh.toFixed(2);
  }

  function calculatePace(totalMeters, elapsedMs){
    if(totalMeters <= 0) return '0:00 /km';
    const secsPerKm = (elapsedMs/1000) / (totalMeters/1000);
    const minutes = Math.floor(secsPerKm/60);
    const seconds = Math.round(secsPerKm % 60).toString().padStart(2,'0');
    return `${minutes}:${seconds} /km`;
  }

  function speak(text){
    if(!('speechSynthesis' in window)) return;
    const utter = new SpeechSynthesisUtterance(text);
    utter.lang = 'pt-BR';
    speechSynthesis.cancel();
    speechSynthesis.speak(utter);
  }

  function updateUI(){
    el.distance.textContent = formatDistance(totalMeters);
    const elapsedMs = Date.now() - startTime;
    el.time.textContent = formatTime(elapsedMs);
    // velocidade instantânea média
    const avgSpeedMs = elapsedMs>0 ? (totalMeters / (elapsedMs/1000)) : 0;
    el.speed.textContent = `${formatSpeedMetersPerSec(avgSpeedMs)} km/h`;
    el.pace.textContent = calculatePace(totalMeters, elapsedMs);
  }

  function onPosition(pos){
    if(paused) return;
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    const acc = pos.coords.accuracy; // metros

    // ignorar leituras com accuracy muito alta
    if(acc > 30) {
      log(`Ignorado por baixa precisão: ${acc}m`);
      return;
    }

    const point = [lat, lon];
    coords.push({lat, lon, time: pos.timestamp});
    polyline.addLatLng(point);

    if(lastPos){
      const d = haversine(lastPos.lat, lastPos.lon, lat, lon);
      // evitar jitter muito pequeno
      if(d >= 0.5){
        totalMeters += d;
      }
    } else {
      // primeira posição: centraliza no mapa
      map.setView(point, 17);
    }

    lastPos = {lat, lon};
    updateUI();

    // ---- ALCANCE DE PROGRESSO A CADA X METROS ----
    if (progressStep > 0 && totalMeters >= nextProgressMark && !targetReached) {
        const partialTimeMs = Date.now() - startTime;
        const partialFormatted = formatTime(partialTimeMs);

        speak(`${nextProgressMark} metros atingidos.`);
        speak("Tempo total até agora:");
        speakTime(partialTimeMs);
        log(`Marco atingido: ${nextProgressMark}m`);

        // Preparar próximo marco
        nextProgressMark += progressStep;
    }

    // --- CHECAR SE A DISTÂNCIA ALVO FOI ATINGIDA ---
    if (targetDistance > 0 && !targetReached && totalMeters >= targetDistance) {
      targetReached = true;

      const now = Date.now();
      const totalMs = now - startTime;
      const totalFmt = formatTime(totalMs);

      speak(`Meta final de ${targetDistance} metros alcançada.`);
      speak("Tempo total:");
      speakTime(totalMs);

      log(`Meta final: ${targetDistance}m | Total: ${totalFmt}`);
    }

  }

  function speakTime(ms) {
    let totalSeconds = Math.floor(ms / 1000);

    const hours = Math.floor(totalSeconds / 3600);
    totalSeconds %= 3600;

    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;

    let parts = [];

    if (hours > 0) {
        parts.push(hours === 1 ? "1 hora" : `${hours} horas`);
    }

    if (minutes > 0) {
        parts.push(minutes === 1 ? "1 minuto" : `${minutes} minutos`);
    }

    if (seconds > 0) {
        parts.push(seconds === 1 ? "1 segundo" : `${seconds} segundos`);
    }

    if (parts.length === 0) {
        parts = ["0 segundos"];
    }

    speak(parts.join(", "));
}


  function onError(err){
    log('Erro geolocation: ' + err.message);
    alert('Erro de localização: ' + err.message);
  }

  function startTracking(){
    if(!('geolocation' in navigator)){
      alert('Geolocation não disponível neste navegador');
      return;
    }

    document.getElementById('map').classList.add('hidden');

    targetDistance = Number(document.getElementById('targetDistance').value) || 0;
    progressStep = Number(document.getElementById('progressStep').value) || 0;

    targetReached = false;

    // Definir o primeiro marco de progressão
    if (progressStep > 0) {
        nextProgressMark = progressStep;
    }

    targetDistance = Number(document.getElementById('targetDistance').value) || 0;
    reachedTarget = false;
    lastTargetTime = Date.now();

    totalMeters = 0; coords = []; lastPos = null;
    startTime = Date.now();
    el.startBtn.disabled = true; el.pauseBtn.disabled = false; el.stopBtn.disabled = false;
    el.logtxt && (el.logtxt.textContent = '');

    // timer UI
    timerInterval = setInterval(updateUI, 1000);

    // watch position com alta precisão
    watchId = navigator.geolocation.watchPosition(onPosition, onError, {
      enableHighAccuracy: true, maximumAge: 1000, timeout: 10000
    });

    speak('Rastreamento iniciado');
    log('Iniciado');
  }
  

  function pauseTracking(){
    if(watchId !== null){
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
      paused = true;
      clearInterval(timerInterval);
      el.pauseBtn.textContent = 'Retomar';
      speak('Pausado');
      log('Pausado');
    } else {
      // retomar
      paused = false;
      el.pauseBtn.textContent = 'Pausar';
      timerInterval = setInterval(updateUI, 1000);
      watchId = navigator.geolocation.watchPosition(onPosition, onError, { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 });
      speak('Retomado');
      log('Retomado');
    }
  }

  function stopTracking(){
    if(watchId !== null){ navigator.geolocation.clearWatch(watchId); watchId = null; }
    clearInterval(timerInterval);
    el.startBtn.disabled = false; el.pauseBtn.disabled = true; el.stopBtn.disabled = true; 
    el.pauseBtn.textContent = 'Pausar';
    paused = false;
    speak(`Parado. Distância total ${Math.round(totalMeters)} metros.`);
    log('Parado');

    document.getElementById('map').classList.remove('hidden');

    // recenter
    if (coords.length > 0) {
        const lat = coords[coords.length - 1].lat;
        const lon = coords[coords.length - 1].lon;
        map.setView([lat, lon], 16);
    }

  }

  // --- Inicialização DOM ---
  document.addEventListener('DOMContentLoaded', () => {
    el.startBtn = document.getElementById('startBtn');
    el.pauseBtn = document.getElementById('pauseBtn');
    el.stopBtn = document.getElementById('stopBtn');
    el.time = document.getElementById('time');
    el.distance = document.getElementById('distance');
    el.speed = document.getElementById('speed');
    el.pace = document.getElementById('pace');
    el.logtxt = document.getElementById('logtxt');

    initMap();

    el.startBtn.addEventListener('click', startTracking);
    el.pauseBtn.addEventListener('click', pauseTracking);
    el.stopBtn.addEventListener('click', stopTracking);

    // se houver permissão prévia, sugerir pedir ao usuário para permitir
    if ('permissions' in navigator && navigator.permissions.query) {
      navigator.permissions.query({name:'geolocation'}).then(result => {
        if(result.state === 'denied') log('Geolocation negado: peça permissão nas configurações do navegador');
      }).catch(()=>{});
    }

    // registrar service worker (PWA)
    if('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then(() => log('Service Worker registrado')).catch(e=>log('SW erro: '+e.message));
    }

    // iOS: instrução para instalar (quando usado como PWA)
  });
  </script>
</body>
</html>


